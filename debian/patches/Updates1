Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 tz-converter (1.0.0-2) UNRELEASED; urgency=medium
 .
   * Added Copyright
Author: David Maiorino (Dave) <maiorinodavid@gmail.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- /dev/null
+++ tz-converter-1.0.0/.pybuild/pythonX.Y_2.7/.pydistutils.cfg
@@ -0,0 +1,8 @@
+[clean]
+all=1
+[build]
+build-lib=/home/dave/Desktop/test2/deb_dist/tz-converter-1.0.0/.pybuild/pythonX.Y_2.7/build
+[install]
+install-layout=deb
+install-scripts=/usr/bin
+install-lib=/usr/lib/python2.7/dist-packages
--- /dev/null
+++ tz-converter-1.0.0/.pybuild/pythonX.Y_3.4/.pydistutils.cfg
@@ -0,0 +1,8 @@
+[clean]
+all=1
+[build]
+build-lib=/home/dave/Desktop/test2/deb_dist/tz-converter-1.0.0/.pybuild/pythonX.Y_3.4/build
+[install]
+install-layout=deb
+install-scripts=/usr/bin
+install-lib=/usr/lib/python3.4/dist-packages
--- /dev/null
+++ tz-converter-1.0.0/lib/delorean/__init__.py
@@ -0,0 +1,21 @@
+from .exceptions import DeloreanInvalidTimezone, DeloreanInvalidDatetime
+
+from dateutil.rrule import (
+                            YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY,
+                            MINUTELY, SECONDLY, MO, TU, WE, TH, FR,
+                            SA, SU
+)
+
+from .interface import (
+                        parse, stops, epoch, flux, utcnow, now,
+                        range_hourly, range_daily, range_monthly,
+                        range_yearly
+)
+
+from .dates import (
+                   move_datetime_second, move_datetime_minute,
+                   move_datetime_hour, move_datetime_day, 
+                   move_datetime_week, move_datetime_month, 
+                   move_datetime_year, move_datetime_namedday, 
+                   Delorean, datetime_timezone, localize, normalize
+)
--- /dev/null
+++ tz-converter-1.0.0/lib/delorean/dates.py
@@ -0,0 +1,366 @@
+import sys
+from datetime import datetime
+from functools import partial, update_wrapper
+
+import pytz
+from pytz import timezone
+from dateutil.relativedelta import relativedelta
+
+from .exceptions import DeloreanInvalidTimezone
+
+UTC = "UTC"
+utc = timezone("UTC")
+
+
+def get_total_second(td):
+    """
+    This method takes a timedelta and return the number of seconds it
+    represents with the resolution of 10 **6
+    """
+    return (td.microseconds + (td.seconds + td.days * 24 * 3600) * 1e6) / 1e6
+
+
+def is_datetime_naive(dt):
+    """
+    This method returns true if the datetime is naive else returns false
+    """
+    if dt is None:
+        return True
+
+    if dt.tzinfo is None:
+        return True
+    else:
+        return False
+
+
+def _move_datetime(dt, direction, delta):
+    """
+    Move datetime given delta by given direction
+    """
+    if direction == 'next':
+        dt = dt + delta
+    elif direction == 'last':
+        dt = dt - delta
+    else:
+        pass
+        # raise some delorean error here
+    return dt
+
+
+def move_datetime_day(dt, direction, num_shifts):
+    delta = relativedelta(days=+num_shifts)
+    return _move_datetime(dt, direction, delta)
+
+
+def move_datetime_namedday(dt, direction, unit):
+    TOTAL_DAYS = 7
+    days = {
+        'monday': 1,
+        'tuesday': 2,
+        'wednesday': 3,
+        'thursday': 4,
+        'friday': 5,
+        'saturday': 6,
+        'sunday': 7,
+    }
+
+    current_day = days[dt.strftime('%A').lower()]
+    target_day = days[unit.lower()]
+
+    if direction == 'next':
+        if current_day < target_day:
+            delta_days = target_day - current_day
+        else:
+            delta_days = (target_day - current_day) + TOTAL_DAYS
+    elif direction == 'last':
+
+        if current_day <= target_day:
+            delta_days = (current_day - target_day) + TOTAL_DAYS
+        else:
+            delta_days = current_day - target_day
+
+    delta = relativedelta(days=+delta_days)
+    return _move_datetime(dt, direction, delta)
+
+
+def move_datetime_month(dt, direction, num_shifts):
+    """
+    Move datetime 1 month in the chosen direction.
+    unit is a no-op, to keep the API the same as the day case
+    """
+    delta = relativedelta(months=+num_shifts)
+    return _move_datetime(dt, direction, delta)
+
+
+def move_datetime_week(dt, direction, num_shifts):
+    """
+    Move datetime 1 week in the chosen direction.
+    unit is a no-op, to keep the API the same as the day case
+    """
+    delta = relativedelta(weeks=+num_shifts)
+    return _move_datetime(dt, direction, delta)
+
+
+def move_datetime_year(dt, direction, num_shifts):
+    """
+    Move datetime 1 year in the chosen direction.
+    unit is a no-op, to keep the API the same as the day case
+    """
+    delta = relativedelta(years=+num_shifts)
+    return _move_datetime(dt, direction, delta)
+
+def move_datetime_hour(dt, direction, num_shifts):
+    delta = relativedelta(hours=+num_shifts)
+    return _move_datetime(dt, direction, delta)
+
+def move_datetime_minute(dt, direction, num_shifts):
+    delta = relativedelta(minutes=+num_shifts)
+    return _move_datetime(dt, direction, delta)
+
+def move_datetime_second(dt, direction, num_shifts):
+    delta = relativedelta(seconds=+num_shifts)
+    return _move_datetime(dt, direction, delta)
+
+def datetime_timezone(tz):
+    """
+    This method given a timezone returns a localized datetime object.
+    """
+    utc_datetime_naive = datetime.utcnow()
+    # return a localized datetime to UTC
+    utc_localized_datetime = localize(utc_datetime_naive, UTC)
+    # normalize the datetime to given timezone
+    normalized_datetime = normalize(utc_localized_datetime, tz)
+    return normalized_datetime
+
+
+def localize(dt, tz):
+    """
+    Given a naive datetime object this method will return a localized
+    datetime object
+    """
+    tz = timezone(tz)
+    return tz.localize(dt)
+
+
+def normalize(dt, tz):
+    """
+    Given a object with a timezone return a datetime object
+    normalized to the proper timezone.
+
+    This means take the give localized datetime and returns the
+    datetime normalized to match the specificed timezone.
+    """
+    tz = timezone(tz)
+    dt = tz.normalize(dt)
+    return dt
+
+
+class Delorean(object):
+    """
+    The class `Delorean <Delorean>` object. This method accepts naive
+    datetime objects, with a string timezone.
+    """
+    _VALID_SHIFT_DIRECTIONS = ('last', 'next')
+    _VALID_SHIFT_UNITS = ('second', 'minute', 'hour', 'day', 'week', 
+                          'month', 'year', 'monday', 'tuesday', 'wednesday',
+                          'thursday', 'friday', 'saturday','sunday')
+
+    def __init__(self, datetime=None, timezone=None):
+        # maybe set timezone on the way in here. if here set it if not
+        # use UTC
+        naive = True
+        self._tz = timezone
+        self._dt = datetime
+
+        if not is_datetime_naive(datetime):
+            # if already localized find the zone
+            # once zone is found set _tz and the localized datetime
+            # to _dt
+            naive = False
+            zone = datetime.tzinfo.tzname(None)
+            self._tz = zone
+            self._dt = datetime
+
+        if naive:
+            if timezone is None and datetime is None:
+                self._tz = UTC
+                self._dt = datetime_timezone(UTC)
+            elif timezone is not None and datetime is None:
+                # create utctime then normalize to tz
+                self._tz = timezone
+                self._dt = datetime_timezone(timezone)
+            elif timezone is None and datetime is not None:
+                raise DeloreanInvalidTimezone('Provide a valid timezone')
+            else:
+                # passed in naive datetime and timezone
+                # that correspond accordingly
+                self._tz = timezone
+                self._dt = localize(datetime, timezone)
+
+    def __repr__(self):
+        return 'Delorean(datetime=%s, timezone=%s)' % (self._dt, self._tz)
+
+    def __eq__(self, other):
+        if isinstance(other, Delorean):
+            return self._dt == other._dt and self._tz == other._tz
+        return False
+
+    def __lt__(self, other):
+        return self.epoch() < other.epoch()
+
+    def __gt__(self, other):
+        return self.epoch() > other.epoch()
+
+    def __ge__(self, other):
+        return self.epoch() >= other.epoch()
+
+    def __le__(self, other):
+        return self.epoch() <= other.epoch()
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __getattr__(self, name):
+        """
+        Implement __getattr__ to call `shift_date` function when function
+        called does not exist
+        """
+        func_parts = name.split('_')
+        # is the func we are trying to call the right length?
+        if len(func_parts) != 2:
+            raise AttributeError
+
+        # is the function we are trying to call valid?
+        if (func_parts[0] not in self._VALID_SHIFT_DIRECTIONS or
+                func_parts[1] not in self._VALID_SHIFT_UNITS):
+            return AttributeError
+
+        # dispatch our function
+        func = partial(self._shift_date, func_parts[0], func_parts[1])
+        # update our partial with self.shift_date attributes
+        update_wrapper(func, self._shift_date)
+        return func
+
+    def _shift_date(self, direction, unit, *args):
+        """
+        Shift datetime in `direction` in _VALID_SHIFT_DIRECTIONS and by some
+        unit in _VALID_SHIFTS and shift that amount by some multiple,
+        defined by by args[0] if it exists
+        """
+        this_module = sys.modules[__name__]
+
+        num_shifts = 1
+        if len(args) > 0:
+            num_shifts = int(args[0])
+
+        if unit in ['monday', 'tuesday', 'wednesday', 'thursday', 'friday',
+                    'saturday', 'sunday']:
+            shift_func = move_datetime_namedday
+            dt = shift_func(self._dt, direction, unit)
+            if num_shifts > 1:
+                for n in range(num_shifts - 1):
+                    dt = shift_func(dt, direction, unit)
+        else:
+            shift_func = getattr(this_module, 'move_datetime_%s' % unit)
+            dt = shift_func(self._dt, direction, num_shifts)
+
+        return Delorean(datetime=dt.replace(tzinfo=None), timezone=self._tz)
+
+    def timezone(self):
+        """
+        This method return a valid pytz timezone object associated with
+        the Delorean object or raises Invalid Timezone error.
+        """
+        if self._tz is None:
+            return None
+        try:
+            return timezone(self._tz)
+        except pytz.exceptions.UnknownTimeZoneError:
+            # raise some delorean error
+            raise DeloreanInvalidTimezone('Provide a valid timezone')
+
+    def truncate(self, s):
+        """
+        Truncate the delorian object to the nearest s
+        (second, minute, hour, day, month, year)
+
+        This is a destructive method, modifies the internal datetime
+        object associated with the Delorean object.
+
+        """
+        if s == 'second':
+            self._dt = self._dt.replace(microsecond=0)
+        elif s == 'minute':
+            self._dt = self._dt.replace(second=0, microsecond=0)
+        elif s == 'hour':
+            self._dt = self._dt.replace(minute=0, second=0, microsecond=0)
+        elif s == 'day':
+            self._dt = self._dt.replace(hour=0, minute=0, second=0, microsecond=0)
+        elif s == 'month':
+            self._dt = self._dt.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
+        elif s == 'year':
+            self._dt = self._dt.replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
+        else:
+            raise ValueError("Invalid truncation level")
+
+        return self
+
+    def next_day(self, days):
+        dt = self._dt + relativedelta(days=+days)
+        dt = dt.replace(tzinfo=None)
+        return Delorean(datetime=dt, timezone=self._tz)
+
+    def naive(self):
+        """
+        Returns a naive datetime object associated with the Delorean
+        object, this method simply converts the localize datetime to UTC
+        and removes the tzinfo that is associated with it.
+        """
+        return utc.normalize(self._dt).replace(tzinfo=None)
+
+    def midnight(self):
+        """
+        This method returns midnight for datetime associated with
+        the Delorean object.
+        """
+        return self._dt.replace(hour=0, minute=0, second=0, microsecond=0)
+
+    def shift(self, tz):
+        """
+        This method shifts the timezone from the current timezone to the
+        specified timezone associated with the Delorean object
+        """
+        try:
+            zone = timezone(tz)
+        except pytz.UnknownTimeZoneError:
+            raise DeloreanInvalidTimezone('Provide a valid timezone')
+        self._tz = tz
+        self._dt = zone.normalize(self._dt)
+        return self
+
+    def epoch(self):
+        """
+        This method returns the total seconds since epoch associated with
+        the Delorean object.
+        """
+        utc = timezone(UTC)
+        epoch = utc.localize(datetime.utcfromtimestamp(0))
+        dt = utc.normalize(self._dt)
+        delta = dt - epoch
+        return get_total_second(delta)
+
+    @property
+    def date(self):
+        """
+        This method returns the actual date object associated with
+        the Delorean object.
+        """
+        return self._dt.date()
+
+    @property
+    def datetime(self):
+        """
+        This method returns the actual datetime object associated with
+        the Delorean object.
+        """
+        return self._dt
--- /dev/null
+++ tz-converter-1.0.0/lib/delorean/exceptions.py
@@ -0,0 +1,26 @@
+class DeloreanError(Exception):
+    """
+    Base Delorean Exception class
+    """
+
+    def __init__(self, msg):
+        self.msg = str(msg)
+        Exception.__init__(self, msg)
+
+    def __str__(self):
+        return self.msg
+
+
+class DeloreanInvalidTimezone(DeloreanError):
+    """
+    Exception that is raised when an invalid timezone is passed in.
+    """
+    pass
+
+
+class DeloreanInvalidDatetime(DeloreanError):
+    """
+    Exception that is raised when an improper datetime object is passed
+    in.
+    """
+    pass
--- /dev/null
+++ tz-converter-1.0.0/lib/delorean/interface.py
@@ -0,0 +1,124 @@
+from datetime import datetime
+
+from pytz import timezone
+from dateutil.rrule import rrule, DAILY, HOURLY, MONTHLY, YEARLY
+from dateutil.parser import parse as capture
+
+from .exceptions import DeloreanInvalidDatetime
+from .dates import Delorean, is_datetime_naive, datetime_timezone
+
+UTC = "UTC"
+utc = timezone("utc")
+
+
+def parse(s, dayfirst=True, yearfirst=True):
+    """
+    Parses a datetime string in it and returns a `Delorean` object.
+
+    If a timezone is detected in the datetime string it will be
+    normalized to UTC, and a Delorean object with that datetime and
+    timezone will be returned.
+    """
+    try:
+        dt = capture(s, dayfirst=dayfirst, yearfirst=yearfirst)
+    except:
+        # raise a parsing error.
+        raise ValueError("Unknown string format")
+    if dt.tzinfo is None:
+        # assuming datetime object passed in is UTC
+        do = Delorean(datetime=dt, timezone=UTC)
+    else:
+        dt = utc.normalize(dt)
+        # makeing dt naive so we can pass it to Delorean
+        dt = dt.replace(tzinfo=None)
+        # if parse string has tzinfo we return a normalized UTC
+        # delorean object that represents the time.
+        do = Delorean(datetime=dt, timezone=UTC)
+    return do
+
+
+def range_daily(start=None, stop=None, timezone=UTC, count=None):
+    """
+    This an alternative way to generating sets of Delorean objects with
+    DAILY stops
+    """
+    return stops(start=start, stop=stop, freq=DAILY, timezone=timezone, count=count)
+
+
+def range_hourly(start=None, stop=None, timezone=UTC, count=None):
+    """
+    This an alternative way to generating sets of Delorean objects with
+    HOURLY stops
+    """
+    return stops(start=start, stop=stop, freq=HOURLY, timezone=timezone, count=count)
+
+
+def range_monthly(start=None, stop=None, timezone=UTC, count=None):
+    """
+    This an alternative way to generating sets of Delorean objects with
+    MONTHLY stops
+    """
+    return stops(start=start, stop=stop, freq=MONTHLY, timezone=timezone, count=count)
+
+
+def range_yearly(start=None, stop=None, timezone=UTC, count=None):
+    """
+    This an alternative way to generating sets of Delorean objects with
+    YEARLY stops
+    """
+    return stops(start=start, stop=stop, freq=YEARLY, timezone=timezone, count=count)
+
+
+def stops(freq, interval=1, count=None, wkst=None, bysetpos=None,
+          bymonth=None, bymonthday=None, byyearday=None, byeaster=None,
+          byweekno=None, byweekday=None, byhour=None, byminute=None,
+          bysecond=None, timezone=UTC, start=None, stop=None):
+    """
+    This will create a list of delorean objects the apply to
+    setting possed in.
+    """
+    # check to see if datetimees passed in are naive if so process them
+    # with given timezone.
+    if is_datetime_naive(start) and is_datetime_naive(stop):
+        pass
+    else:
+        raise DeloreanInvalidDatetime('Provide a naive datetime object')
+
+    # if no datetimes are passed in create a proper datetime object for
+    # start default because default in dateutil is datetime.now() :(
+    if start is None:
+        start = datetime_timezone(timezone)
+
+    for dt in rrule(freq, interval=interval, count=count, wkst=None, bysetpos=None,
+          bymonth=None, bymonthday=None, byyearday=None, byeaster=None,
+          byweekno=None, byweekday=None, byhour=None, byminute=None,
+          bysecond=None, until=stop, dtstart=start):
+        # make the delorean object
+        # yield it.
+        # doing this to make sure delorean receives a naive datetime.
+        dt = dt.replace(tzinfo=None)
+        d = Delorean(datetime=dt, timezone=timezone)
+        yield d
+
+
+def epoch(s):
+    dt = datetime.utcfromtimestamp(s)
+    return Delorean(datetime=dt, timezone=UTC)
+
+
+def flux():
+    print("If you put your mind to it, you can accomplish anything.")
+
+
+def utcnow():
+    """
+    Return a delorean object, with utcnow as the datetime
+    """
+    return Delorean()
+
+
+def now():
+    """
+    Return a delorean object, with utcnow as the datetime
+    """
+    return utcnow()
--- tz-converter-1.0.0.orig/main_widget.py
+++ tz-converter-1.0.0/main_widget.py
@@ -1,3 +1,5 @@
+#!/usr/bin/python3
+
 import sys
 import os
 real_path = os.path.dirname(os.path.realpath(__file__))
--- tz-converter-1.0.0.orig/timezone_info.py
+++ tz-converter-1.0.0/timezone_info.py
@@ -1,3 +1,5 @@
+#!/usr/bin/python3
+
 """
 
 Contains getters for cities in a specific region.
